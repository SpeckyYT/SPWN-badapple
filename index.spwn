// https://github.com/SpeckyYT/SPWN-canvas
canvas = import '../canvas/canvas.spwn'

screen = ?g

let WIDTH = 36
let HEIGHT = 28
let FWIDTH = WIDTH + 2  // 1: \n | 2: \r\n
let PIXELSIZE = 10/HEIGHT
let SLICEH = 1
let PIXELS = WIDTH * HEIGHT

let STARTFROM = 0       // the frame it should start the animation form
let MAXGENFRAMES = -1   // maximal amount of frames to draw
let DELAY = 0           // the time it waits to start playing
let DELTATIME = 1/20    // 20 fps

let badCanvas = canvas::new(
    0, 0,
    WIDTH, HEIGHT-SLICEH,
    10/(HEIGHT-SLICEH),
    screen
)

let previousFrame = []
for _ in ..PIXELS {
    previousFrame.push(0/0)
}

// https://raw.githubusercontent.com/kevinjycui/bad-apple/master/april-fools/input.txt
let file = @file::new('input.txt')

for index in ..(1/0) {
    if MAXGENFRAMES >= 0 && index >= MAXGENFRAMES {break}

    $.print(index, ' frames done')

    let currentFrame = []
    for _ in ..(1/0) {
        if currentFrame.length >= HEIGHT {break}

        let seekIndex =
            STARTFROM * FWIDTH * HEIGHT +   // BASE INDEX
            index * FWIDTH * HEIGHT +       // FRAME INDEX
            currentFrame.length * FWIDTH    // LINE INDEX

        file.seek(seekIndex)
        currentFrame.push(file.read(WIDTH))
    }
    if currentFrame.length >= HEIGHT {
        let toPush = []
        for i in (WIDTH*SLICEH)..PIXELS {
            if i / WIDTH > HEIGHT + SLICEH {break}

            let y = HEIGHT - $.floor(i / WIDTH) - 1
            let x = i % WIDTH

            if x >= badCanvas.colors.length {continue}
            if y >= badCanvas.colors[x].length {continue}

            let char = currentFrame[y][x]

            let key = x + y * WIDTH
            if char == previousFrame[key] {continue}
            previousFrame[key] = char

            let mirroredY = badCanvas.colors[x].length-(y+1)

            let color = switch char {
                case '0': 0
                case '1': 255
                else: 128
            }

            toPush.push([
                badCanvas.colors[x][mirroredY],
                color,
            ])
        }
        call_with_delay(index * DELTATIME + DELAY, !{
            for push in toPush {
                colorG = push[0]
                color = push[1]
                colorG.set(color,color,color)
            }
        })
    }
}

hide_player()
screen.move(15,0,1)
screen.lock_to_player(true,false)
